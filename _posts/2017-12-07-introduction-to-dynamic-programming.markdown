---
layout: post
title: Introduction to Dynamic Programming
date: 2017-12-06 17:24
comments: true
external-url: introduction-to-dynamic-programming
categories:
- Algorithms
comments: true
---

<script src='https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.1/Chart.bundle.js'></script>

Dynamic programming is one of the core algorithmic techniques in all of computer science.
It is a very general technique that can be applied to many problems.
I chose to write a blog post on this topic because it is the perfect sweet spot of a technique that is surprisingly useful, and one where visual intuition can be core to understanding.

The principle is simple:

1. Express your problem in terms of overlapping _subproblems_.
2. Solve the subproblems, and **save the solution**.
3. If the subproblem is ever seen again, you return the saved solution rather than computing it again.

---

If you have seen Pascal's triangle before, you have seen dynamic programming.

<center><img src='/assets/pascal.png' style='max-width: 175px'/></center>
<br>

Pascal's triangle is generated by a simple recurrence relation: each digit is the sum of the two digits directly above it.
Another representation of Pascal's triangle is in a table, as follows:


| 1 | 1 | 1  | 1     |
| 1 | 2 | 3  | 4     |
| 1 | 3 | 6  | 10    |
| 1 | 4 | 10 | **?** |

What if I asked you what the value is in the bottom right corner of the table?
It's obviously 20, which is the sum of digits above and to the left of the digit.
But importantly, **this was only easy because you had access to a table, and most of it was filled in already**.

This is exactly the crux of dynamic programming: **table-filling**.

Here's a challenge: try to find that same value, with the constraint that you can't use a table of any sort (this includes writing down the triangle).
It's much harder, and extremely tedious to do (note that $$P_{i,j}$$ represents the value of the $$i$$-th row and $$j$$-th column):

$$
\begin{aligned}
P_{4,4} &= P_{3,4} + P_{4,3} \\
        &= (P_{2,4} + P_{3,3}) + (P_{3,3} + P_{4,2}) \\
        &= ((P_{1,4} + P_{2,3}) + (P_{2,3} + P_{3,2})) + ((P_{2,3} + P_{3,2}) + (P_{3,2} + P_{4,3})) \\
        &= \cdots \\
        &= 1 + 1 + 1 + ... + 1 \\
\end{aligned}
$$

Notice that in this computation, many values appeared more than once (for example, $$P_{3,3}$$ and $$P_{2,3}$$).
This is exactly what is meant by _overlapping_ subproblems.
The key idea is that once you solve the subproblem once, you don't need to solve it again.
Just save the value, and return that value the next time you need it.
With this framework, it is possible to achieve huge speedups.

---

## The Fibonacci sequence

The Fibonacci sequence is a commonly used example when first teaching about dynamic programming. It has the following recursive definition:

$$
\begin{aligned}
\text{Fibonacci}(n) &= \text{Fibonacci}(n-1) + \text{Fibonacci}(n-2) \\
\text{Fibonacci}(1) &= 1 \\
\text{Fibonacci}(2) &= 1 \\
\end{aligned}
$$

The task is, calculate the value of $$\text{Fibonacci}(1000)$$.

### Brute Force Solution

The natural solution, then, if you're doing it in Python, would be to write it like so:

```python
def fibonacci(n):
    if n <= 2:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
```

While this produces the correct answer, it is much too slow.
In fact, the amount of time needed to produce the correct answer is exponential in the input size.

<center><canvas id="myChart" width="500" height="200"></canvas></center>
<script>
var ctx = document.getElementById("myChart").getContext('2d');

new Chart(ctx, {
  type: 'line',
  data: {
    labels: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35],
    datasets: [{ 
        data: [9.5367431640625e-07, 0.0, 9.5367431640625e-07, 1.1920928955078125e-06, 9.5367431640625e-07, 1.1920928955078125e-06, 1.6689300537109375e-06, 4.0531158447265625e-06, 6.9141387939453125e-06, 1.0967254638671875e-05, 1.9073486328125e-05, 3.0279159545898438e-05, 4.76837158203125e-05, 7.796287536621094e-05, 0.000125885009765625, 0.0002040863037109375, 0.0003299713134765625, 0.0005359649658203125, 0.0008649826049804688, 0.0014002323150634766, 0.002213716506958008, 0.003506898880004883, 0.005950212478637695, 0.010439157485961914, 0.013570070266723633, 0.02274918556213379, 0.036482810974121094, 0.061415910720825195, 0.09200716018676758, 0.1400151252746582, 0.22507500648498535, 0.37235498428344727, 0.6324710845947266, 1.0376629829406738, 1.646972894668579],
        label: "Naive Fibonacci algorithm",
        borderColor: "#3e95cd",
        fill: false
      }
    ]
  },
  options: {
    title: {
      display: true,
      text: 'Computation time for naive Fibonacci algorithm'
    },
    scales: {
        yAxes: [{
            scaleLabel: {
                display: true,
                labelString: 'Computation time (seconds)'
            }
        }],
        xAxes: [{
            scaleLabel: {
                display: true,
                labelString: 'Value of n'
            }
        }]
    }
  }
});
</script>
<br>

(I generated the plot with [this code](https://gist.github.com/stevenschmatz/e72e7e4a966c5cfcc1cc4876777b4498)).

The reason for this is that each call to `fibonacci` makes two more calls to `fibonacci`, and hence, twice the amount of addition must be done.
For large values of `n`, this creates an exponential amount of work.

<center><img src='/assets/fib_tree.gif'/></center>

### DP Solution

Instead, let's treat the problem like filling up a table.
This table would only have one dimension, which represents the value of $$n$$, and its value would represent $$\text{Fibonacci}(n)$$.
We can fill the table like so:

<center><img src='/assets/Fibonacci.gif'/></center>

Notably, the amount of addition is _linear_ with $$n$$, rather than being exponential in $$n$$.
This is a massive improvement!
The corresponding Python implementation would look something like this:

```python
def fibonacci(n):
    table = [1, 1]

    while len(table) < n:
        table.append(table[-1] + table[-2])

    return table[-1]
```

And as can be seen by the following plot, this leads to a massive speedup.
Values of $$n$$ much larger than 100,000 can be calculated in under a second.
And more importantly, the shape of this curve is roughly linear, so this method scales very well to high $$n$$.

<center><canvas id="myChart2" width="500" height="200"></canvas></center>
<script>
var ctx = document.getElementById("myChart2").getContext('2d');

new Chart(ctx, {
  type: 'line',
  data: {
    labels: [0, 2000, 4000, 6000, 8000, 10000, 12000, 14000, 16000, 18000, 20000, 22000, 24000, 26000, 28000, 30000, 32000, 34000, 36000, 38000, 40000, 42000, 44000, 46000, 48000, 50000, 52000, 54000, 56000, 58000, 60000, 62000, 64000, 66000, 68000, 70000, 72000, 74000, 76000, 78000, 80000, 82000, 84000, 86000, 88000, 90000, 92000, 94000, 96000, 98000, 100000, 102000, 104000, 106000, 108000, 110000, 112000, 114000, 116000, 118000, 120000, 122000, 124000, 126000, 128000, 130000, 132000, 134000, 136000, 138000, 140000, 142000, 144000, 146000, 148000, 150000, 152000, 154000, 156000, 158000, 160000, 162000, 164000, 166000, 168000, 170000, 172000, 174000, 176000, 178000, 180000, 182000, 184000, 186000, 188000, 190000, 192000, 194000, 196000, 198000, 200000],
    datasets: [{ 
        data: [0.00010797977447509765, 0.0003670692443847656, 0.00064444541931152344, 0.00097455978393554685, 0.0013138532638549804, 0.0017793655395507812, 0.0024563550949096681, 0.0029388666152954102, 0.0038981199264526366, 0.0044621706008911135, 0.0055062770843505859, 0.0067059278488159181, 0.0075804710388183592, 0.0086019515991210931, 0.0088600397109985345, 0.009524130821228027, 0.010118865966796875, 0.010979652404785156, 0.012162590026855468, 0.01330859661102295, 0.014607477188110351, 0.015075373649597167, 0.016496276855468749, 0.018826770782470702, 0.019403815269470215, 0.020171332359313964, 0.022587800025939943, 0.024281907081604003, 0.024327516555786133, 0.025886964797973634, 0.028889346122741699, 0.029339313507080078, 0.031336045265197753, 0.032495546340942386, 0.034292840957641603, 0.037045311927795407, 0.038236069679260257, 0.039321708679199222, 0.042940831184387206, 0.049130892753601073, 0.046868610382080081, 0.047943377494812013, 0.049889159202575681, 0.052187013626098636, 0.054119467735290527, 0.05567302703857422, 0.059745264053344724, 0.062710833549499509, 0.065771746635437014, 0.067776155471801755, 0.068351340293884275, 0.069491147994995117, 0.074594259262084961, 0.08041014671325683, 0.085471487045288091, 0.086806082725524897, 0.09243011474609375, 0.097210359573364255, 0.10153110027313232, 0.10564670562744141, 0.11830813884735107, 0.11659996509552002, 0.11056275367736816, 0.11745080947875977, 0.13068137168884278, 0.13613464832305908, 0.13269374370574952, 0.13251173496246338, 0.14033253192901612, 0.14430520534515381, 0.15157558917999267, 0.16639280319213867, 0.16532962322235106, 0.1737987756729126, 0.17527685165405274, 0.18036580085754395, 0.18649814128875733, 0.1923449993133545, 0.19486937522888184, 0.2012939691543579, 0.21317560672760011, 0.21403045654296876, 0.21996827125549318, 0.22827184200286865, 0.23043584823608398, 0.23686740398406983, 0.24637329578399658, 0.24696567058563232, 0.26688377857208251, 0.27707006931304934, 0.26955435276031492, 0.28359761238098147, 0.2872927188873291, 0.29862267971038819, 0.30066723823547364, 0.30973105430603026, 0.31340410709381106, 0.3179576635360718, 0.34124567508697512, 0.33573427200317385],
        label: "Dynamic Programming Fibonacci algorithm",
        borderColor: "#3e95cd",
        fill: false
      }
    ]
  },
  options: {
    title: {
      display: true,
      text: 'Computation time for table-filling Fibonacci algorithm'
    },
    scales: {
        yAxes: [{
            scaleLabel: {
                display: true,
                labelString: 'Computation time (seconds)'
            }
        }],
        xAxes: [{
            scaleLabel: {
                display: true,
                labelString: 'Value of n'
            }
        }]
    }
  }
}); m
</script>
<br>

---

## Tri-tiling

Let's try a slightly more difficult problem. Given a $$(3 \times n)$$ board, find the number of ways to fill it with dominoes of length 2.
Here is one possible solution:

<br>
<center><img src='/assets/tiling.png'/></center>
<br>

First, we start by defining a subproblem $$D_n$$ which represents the number of tilings of a board of length $$n$$.
This time, though, the recurrence relation is significantly more tricky, because you can end up with intermediate boards of two different forms:


<br>
<center><img src='/assets/tiling2.png'/></center>
<br>

### Observations

* The only intermediate forms which are valid either are completely filled at the end, or have one empty hole at a corner.

* It is not possible to have a fully-tiled board of odd length (try for yourself).

* Also, other intermediate forms (two empty squares on the corners, one empty square in the center) are not valid intermediate solutions either.

### Recurrence

What if instead of using just one recurrence relation, we used **multiple recurrence relations**, one for each intermediate solution type?

Let's call $$f(n)$$ the number of ways to tile a $$(3 \times n)$$ board such that it has a flat end, and $$g(n)$$ the number of ways to tile a $$(3 \times n)$$ board such that it has one corner missing.

<center><img src='/assets/tiling_recursion_1.gif'/></center>

Also note that our base cases for $$f$$ are $$f(0) = 1$$, since there is only one way to tile an empty board, and $$f(1) = 0$$, since it is impossible to tile a board of length 1.
We can also express $$g(x)$$ recursively:

<center><img src='/assets/tiling_recursion_2.gif'/></center>

With base cases $$g(0) = 0$$, since there are no ways to tile zero spots with a missing square, and $$g(1) = 1$$, since you can make one tiling with a missing square in a $$(1 \times 3)$$ board.

To reiterate, we get the following recurrence relations:

$$
\begin{aligned}
f(n) &= f(n-2) + 2*g(n-1) \\
f(0) &= 1 \\
f(1) &= 0 \\
\\
g(n) &= f(n-1) + g(n-2) \\
g(0) &= 0 \\
g(1) &= 1 \\
\end{aligned}
$$

This means that this is what our table-filling algorithm would look like this:

<br>
<center><img src='/assets/table.gif' style='max-width: 400px'/></center>
<br>

Notice that we alternate between finding values of $$f(x)$$ and $$g(x)$$.
This illustrates the fact that DP algorithms can fill tables in complex ways.
The one invariant, though, is that tables must be filled from left to right or top to bottom.
This corresponds to the fact that larger solutions must consist of smaller solutions.
Our corresponding Python function might look like this:

```python
def tri_tiling(n):
    f = [1, 0]; g = [0, 1]
    
    while len(f) <= n:
        next_f = f[-2] + 2*g[-1]
        next_g = f[-1] + g[-2]
        f.append(next_f)
        g.append(next_g)
    
    return f[n]
```

Note that we store our values in intermediate variables, because otherwise we would be modifying the length of the array and hence in the `next_g` line we would get the wrong value from `f[-1]`.

---

As you can see, dynamic programming can be an incredibly powerful paradigm.
Even simple linear table-filling algorithms like the one presented for Fibonacci can make an exponential algorithm run in linear time.
As was shown in the second example, there can be a large amount of variety in how values are constructed from previous values.
In my [next post](https://stevenschmatz.github.io/blog/2017/12/07/intermediate-dynamic-programming/), I will cover dynamic programming algorithms that operate on two-dimensional tables and even trees.
